{"compress":true,"commitItems":[["e9c36e8c-a617-4e0d-bfc3-1d9801150cb2",1521136321702,"[TOC]\n\n# 1 数据类型\n\nHive所有数据类型分为四种类型，给出如下：\n\n- 列类型\n- 文字\n- Null 值\n- 复杂类型\n\n## 1.1 列类型\n\n列类型被用作Hive的列数据类型。它们如下：\n\n- 整型\n  | 类型       | 后缀   | 示例   |\n  | -------- | ---- | ---- |\n  | TINYINT  | Y    | 10Y  |\n  | SMALLINT | S    | 10S  |\n  | INT      | -    | 10   |\n  | BIGINT   | L    | 10L  |\n\n- 字符串类型\n\n  字符串类型的数据类型可以使用单引号('')或双引号(“”)来指定\n\n  | 数据类型    | 长度         |\n  | ------- | ---------- |\n  | VARCHAR | 1 to 65355 |\n  | CHAR    | 255        |\n\n- 时间戳\n\n  它支持传统的UNIX时间戳可选纳秒的精度。它支持的java.sql.Timestamp格式“YYYY-MM-DD HH:MM:SS.fffffffff”和格式“YYYY-MM-DD HH:MM:ss.ffffffffff”。\n\n- 日期\n\n  DATE值在年/月/日的格式形式描述 {{YYYY-MM-DD}}.\n\n- 小数点\n\n  ```\n  DECIMAL(precision, scale)\n  decimal(10,0)\n  ```\n\n- 联合类型\n\n  联合是异类的数据类型的集合。可以使用联合创建的一个实例。语法和示例如下：\n\n  ```\n  UNIONTYPE<int, double, array<string>, struct<a:int,b:string>>\n\n  {0:1} \n  {1:2.0} \n  {2:[\"three\",\"four\"]} \n  {3:{\"a\":5,\"b\":\"five\"}} \n  {2:[\"six\",\"seven\"]} \n  {3:{\"a\":8,\"b\":\"eight\"}} \n  {0:9} \n  {1:10.0}\n  ```\n\n\n## 1.2 文字\n\n- 浮点类型\n\n  浮点类型是只不过有小数点的数字。通常，这种类型的数据组成DOUBLE数据类型。\n\n- 十进制类型\n\n  十进制数据类型是只不过浮点值范围比DOUBLE数据类型更大。十进制类型的范围大约是$ -10^{-308}到 10^308$\n\n## 1.3 Null 值\n\n缺少值通过特殊值 - NULL表示。\n\n## 1.4 复杂类型\n\n- 数组\n\n  在Hive 数组与在Java中使用的方法相同。\n\n  ```\n  Syntax: ARRAY<data_type>\n  ```\n\n- 映射\n\n  映射在Hive类似于Java的映射。\n\n  ```\n  Syntax: MAP<primitive_type, data_type>\n  ```\n\n- 结构体\n\n  在Hive结构体类似于使用复杂的数据。\n\n  ```\n  Syntax: STRUCT<col_name : data_type [COMMENT col_comment], ...>\n  ```\n\n# 2 数据库操作\n\nHive是一种数据库技术，可以定义数据库和表来分析结构化数据。\n\n``` \nCREATE DATABASE|SCHEMA [IF NOT EXISTS] <database name>\n\nSHOW DATABASES;\n\n```\n\n```\nDROP DATABASE StatementDROP (DATABASE|SCHEMA) [IF EXISTS] database_name \n[RESTRICT|CASCADE];\n```\n\n\n\n# 3 表操作\n\n## 3.1 创建\n\n```scheme\nCREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.] table_name\n\n[(col_name data_type [COMMENT col_comment], ...)]\n[COMMENT table_comment]\n[ROW FORMAT row_format]\n[STORED AS file_format]\n```\n\n```\nLOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename \n[PARTITION (partcol1=val1, partcol2=val2 ...)]\n```\n\n- LOCAL是标识符指定本地路径。它是可选的。\n- OVERWRITE 是可选的，覆盖表中的数据。\n- PARTITION 这是可选的\n\n## 3.2 修改\n\n```scheme\nALTER TABLE name RENAME TO new_name\nALTER TABLE name ADD COLUMNS (col_spec[, col_spec ...])\nALTER TABLE name DROP [COLUMN] column_name\nALTER TABLE name CHANGE column_name new_name new_type\nALTER TABLE name REPLACE COLUMNS (col_spec[, col_spec ...])\n```\n\n## 3.3 删除表\n\n```\nDROP TABLE [IF EXISTS] table_name;\n```\n\n\n\n# 4 HIVE分区\n\nHive组织表到分区。它是将一个表到基于分区列，如日期，城市和部门的值相关方式。使用分区，很容易对数据进行部分查询。\n\n表或分区是细分成桶，以提供额外的结构，可以使用更高效的查询的数据。桶的工作是基于表的一些列的散列函数值。\n\n例如，一个名为Tab1表包含雇员数据，如 id, name, dept 和yoj (即加盟年份)。假设需要检索所有在2012年加入，查询搜索整个表所需的信息员工的详细信息。但是，如果用年份分区雇员数据并将其存储在一个单独的文件，它减少了查询处理时间。\n\n![(http://ww1.sinaimg.cn/large/0063bT3gly1fmpjhwk61lj30gd0aw74d.jpg)\n\n## 4.1 添加分区\n\n``` scheme\nALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION partition_spec\n[LOCATION 'location1'] partition_spec [LOCATION 'location2'] ...;\n\npartition_spec:\n: (p_column = p_col_value, p_column = p_col_value, ...)\n\n```\n\n举例：\n\n```sql\nhive> ALTER TABLE employee\n> ADD PARTITION (year=’2013’)\n> location '/2012/part2012';\n```\n\n## 4.2 重命名分区\n\n```\nALTER TABLE table_name PARTITION partition_spec RENAME TO PARTITION partition_spec;\n```\n\n举例：\n\n```\nhive> ALTER TABLE employee PARTITION (year=’1203’)\n   > RENAME TO PARTITION (Yoj=’1203’);\n```\n\n## 4.3 删除分区\n\n```\nALTER TABLE table_name DROP [IF EXISTS] PARTITION partition_spec, PARTITION partition_spec,...;\n```\n\n举例：\n\n```\nhive> ALTER TABLE employee DROP [IF EXISTS]\n   > PARTITION (year=’1203’);\n```\n\n# 5 内置运算法\n\n# 6 内置函数\n\n## 6.1 一般函数\n\nHive支持以下内置函数：\n\n| 返回类型            | 签名                                       | 描述                                       |\n| --------------- | ---------------------------------------- | ---------------------------------------- |\n| BIGINT          | round(double a)                          | 返回a最近的BIGINT值。                           |\n| BIGINT          | floor(double a)                          | 返回最大BIGINT值等于或小于a。                       |\n| BIGINT          | ceil(double a)                           | 它返回最小BIGINT值等于或大于a。                      |\n| double          | rand(), rand(int seed)                   | 它返回一个随机数                                 |\n| string          | concat(string A, string B,...)           | 它返回从A后串联B产生的字符串                          |\n| string          | substr(string A, int start)              | 它返回一个起始，从起始位置的子字符串，直到A.结束                |\n| string          | substr(string A, int start, int length)  | 返回从给定长度的起始start位置开始的字符串。                 |\n| string          | upper(string A)                          | 它返回从转换的所有字符为大写产生的字符串。                    |\n|                 |                                          |                                          |\n| string          | ucase(string A)                          | 和上面的一样                                   |\n| string          | lower(string A)                          | 它返回转换B的所有字符为小写产生的字符串。                    |\n| string          | lcase(string A)                          | 和上面的一样                                   |\n| string          | trim(string A)                           | 它返回字符串从A.两端修剪空格的结果                       |\n| string          | ltrim(string A)                          | 它返回A从一开始修整空格产生的字符串(左手侧)                  |\n| string          | rtrim(string A)                          | rtrim(string A)，它返回A从结束修整空格产生的字符串(右侧)    |\n| string          | regexp_replace(string A, string B, string C) | 它返回从替换所有子在B结果配合C.在Java正则表达式语法的字符串        |\n| int             | size(Map<K.V>)                           | 它返回在映射类型的元素的数量。                          |\n| int             | size(Array<T>)                           | 它返回在数组类型元素的数量。                           |\n| value of <type> | cast(<expr> as <type>)                   | 它把表达式的结果expr<类型>如cast('1'作为BIGINT)代表整体转换为字符串'1'。如果转换不成功，返回的是NULL。 |\n| string          | from_unixtime(int unixtime)              | 转换的秒数从Unix纪元(1970-01-0100:00:00 UTC)代表那一刻，在当前系统时区的时间戳字符的串格式：\"1970-01-01 00:00:00\" |\n| string          | to_date(string timestamp)                | 返回一个字符串时间戳的日期部分：to_date(\"1970-01-01 00:00:00\") = \"1970-01-01\" |\n| int             | year(string date)                        | 返回年份部分的日期或时间戳字符串：year(\"1970-01-01 00:00:00\") = 1970, year(\"1970-01-01\") = 1970 |\n| int             | month(string date)                       | 返回日期或时间戳记字符串月份部分：month(\"1970-11-01 00:00:00\") = 11, month(\"1970-11-01\") = 11 |\n| int             | day(string date)                         | 返回日期或时间戳记字符串当天部分：day(\"1970-11-01 00:00:00\") = 1, day(\"1970-11-01\") = 1 |\n| string          | get_json_object(string json_string, string path) | 提取从基于指定的JSON路径的JSON字符串JSON对象，并返回提取的JSON字符串的JSON对象。如果输入的JSON字符串无效，返回NULL。 |\n\n### 示例\n\n以下查询演示了一些内置函数：\n\n**round() 函数**\n\n```\nhive> SELECT round(2.6);\n```\n\n成功执行的查询，能看到以下回应：\n\n```\n3\n```\n\n**floor() 函数**\n\n```\nhive> SELECT floor(2.6) ;\n```\n\n成功执行的查询，能看到以下回应：\n\n```\n2\n```\n\n## 6.2 聚合函数\n\nHive支持以下内置聚合函数。这些函数的用法类似于SQL聚合函数。\n\n| 返回类型   | 签名                          | 描述                         |\n| ------ | --------------------------- | -------------------------- |\n| BIGINT | count(*), count(expr),      | count(*) - 返回检索行的总数。       |\n| DOUBLE | sum(col), sum(DISTINCT col) | 返回该组或该组中的列的不同值的分组和所有元素的总和。 |\n| DOUBLE | avg(col), avg(DISTINCT col) | 返回上述组或该组中的列的不同值的元素的平均值。    |\n| DOUBLE | min(col)                    | 返回该组中的列的最小值。               |\n| DOUBLE | max(col)                    | 返回该组中的列的最大值。               |\n\n# 7 Hive视图和索引\n\n## 7.1 创建一个视图\n\n```\nCREATE VIEW [IF NOT EXISTS] view_name [(column_name [COMMENT column_comment], ...) ]\n[COMMENT table_comment]\nAS SELECT ...\n```\n\n**示例**\n\n举个例子来看。假设employee表拥有如下字段：Id, Name, Salary, Designation 和 Dept。生成一个查询检索工资超过30000卢比的员工详细信息，我们把结果存储在一个名为视图 emp_30000.\n\n```\n+------+--------------+-------------+-------------------+--------+\n| ID   | Name         | Salary      | Designation       | Dept   |\n+------+--------------+-------------+-------------------+--------+\n|1201  | Gopal        | 45000       | Technical manager | TP     |\n|1202  | Manisha      | 45000       | Proofreader       | PR     |\n|1203  | Masthanvali  | 40000       | Technical writer  | TP     |\n|1204  | Krian        | 40000       | Hr Admin          | HR     |\n|1205  | Kranthi      | 30000       | Op Admin          | Admin  |\n+------+--------------+-------------+-------------------+--------+\n\n```\n\n下面使用上述业务情景查询检索员的工详细信息：\n\n```\nhive> CREATE VIEW emp_30000 AS\n   > SELECT * FROM employee\n   > WHERE salary>30000;\n```\n\n## 7.2 删除一个视图\n\n使用下面的语法来删除视图：\n\n```\nDROP VIEW view_name\n```\n\n## 7.3 索引\n\n**创建索引**\n\n索引也不过是一个表上的一个特定列的指针。创建索引意味着创建一个表上的一个特定列的指针。它的语法如下：\n\n```\nCREATE INDEX index_name\nON TABLE base_table_name (col_name, ...)\nAS 'index.handler.class.name'\n[WITH DEFERRED REBUILD]\n[IDXPROPERTIES (property_name=property_value, ...)]\n[IN TABLE index_table_name]\n[PARTITIONED BY (col_name, ...)]\n[\n   [ ROW FORMAT ...] STORED AS ...\n   | STORED BY ...\n]\n[LOCATION hdfs_path]\n[TBLPROPERTIES (...)]\n```\n\n下面的查询创建一个索引：\n\n```\nhive> CREATE INDEX inedx_salary ON TABLE employee(salary)\n   > AS 'org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler';\n   \n这是一个指向salary列。如果列被修改，变更使用的索引值存储。\n```\n\n**删除索引**\n\n```\nDROP INDEX <index_name> ON <table_name>\n```\n\n# 8 HiveQL Select Where\n\n```\nSELECT [ALL | DISTINCT] select_expr, select_expr, ... \nFROM table_reference \n[WHERE where_condition] \n[GROUP BY col_list] \n[HAVING having_condition] \n[CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list]] \n[LIMIT number];\n```",[[1521136307547,["wanghuan@DESKTOP-VT81TGT",[[-1,0,"[TOC]\n"],[1,6,"HIVE"]],[0,0],[4,4]]],[1521136308393,["wanghuan@DESKTOP-VT81TGT",[[1,0,"[TOC]\n"],[-1,0,"HIVE"]],[4,4],[0,0]]],[1521136315769,["wanghuan@DESKTOP-VT81TGT",[[-1,0,"[TOC]\n"],[1,6,"---\ntitle: HIVE介绍\ndate: 2018/3/15 20:46:25\ncategory:\n- 大数据\n- HIVE\ntag:\n- HIVE\ncomments: true  \n---"]],[0,0],[98,98]]],[1521136319284,["wanghuan@DESKTOP-VT81TGT",[[-1,15,"介绍"],[1,17," sql"]],[15,17],[19,19]]]]]]}