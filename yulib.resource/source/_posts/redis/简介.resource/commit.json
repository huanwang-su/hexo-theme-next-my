{"compress":true,"commitItems":[["971134cd-da0e-43ed-9a11-d035e2f72193",1521131253584,"# Redis 简介\n\nRedis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。\n\nRedis 与其他 key - value 缓存产品有以下三个特点：\n\n- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n- Redis支持数据的备份，即master-slave模式的数据备份。\n\n>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：\n>\n>- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。\n>- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。\n>- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。\n>\n>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。\n>\n>很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。\n\n### Redis 优势\n\n- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n- 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\n- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n### Redis与其他key-value存储有什么不同？\n\n- Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\n- Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n\n\n\n\n\n\n## Redis 数据类型\n\nRedis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n\n\n### String（字符串）\n\nstring是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。\n\nstring类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。\n\nstring类型是Redis最基本的数据类型，一个键最大能存储512MB。\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> SET name \"runoob\"\nOK\nredis 127.0.0.1:6379> GET name\n\"runoob\"\n```\n\n在以上实例中我们使用了 Redis 的 **SET** 和 **GET** 命令。键为 name，对应的值为 **runoob**。\n\n**注意：**一个键最大能存储512MB。\n\n\n### Hash（哈希）\n\nRedis hash 是一个键名对集合。\n\nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。\n\n#### 实例\n\n```\n127.0.0.1:6379> HMSET user:1 username runoob password runoob points 200\nOK\n127.0.0.1:6379> HGETALL user:1\n1) \"username\"\n2) \"runoob\"\n3) \"password\"\n4) \"runoob\"\n5) \"points\"\n6) \"200\"\n```\n\n以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis **HMSET, HGETALL** 命令，**user:1** 为键值。\n\n每个 hash 可以存储 2\n\n32\n\n -1 键值对（40多亿）。\n\n### List（列表）\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> lpush runoob redis\n(integer) 1\nredis 127.0.0.1:6379> lpush runoob mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush runoob rabitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange runoob 0 10\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n\n### Set（集合）\n\nRedis的Set是string类型的无序集合。\n\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\n\n#### sadd 命令\n\n添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0,key对应的set不存在返回错误。\n\n```\nsadd key member\n```\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> sadd runoob redis\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob rabitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob rabitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers runoob\n\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\n```\n\n**注意：**以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。\n\n集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。\n\n### zset(sorted set：有序集合)\n\nRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。\n\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\n\nzset的成员是唯一的,但分数(score)却可以重复。\n\n#### zadd 命令\n\n添加元素到集合，元素在集合中存在则更新对应score\n\n```\nzadd key score member \n```\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> zadd runoob 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 rabitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 rabitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE runoob 0 1000\n\n1) \"redis\"\n2) \"mongodb\"\n3) \"rabitmq\"\n```\n\n\n## Redis 命令\n\nRedis 命令用于在 redis 服务上执行操作。\n\n要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。\n\n### 语法\n\nRedis 客户端的基本语法为：\n\n```\n$ redis-cli\n```\n\n### 实例\n\n以下实例讲解了如何启动 redis 客户端：\n\n启动 redis 客户端，打开终端并输入命令 **redis-cli**。该命令会连接本地的 redis 服务。\n\n```\n$redis-cli\nredis 127.0.0.1:6379>\nredis 127.0.0.1:6379> PING\n\nPONG\n```\n\n在以上实例中我们连接到本地的 redis 服务并执行 **PING** 命令，该命令用于检测 redis 服务是否启动。\n\n### 在远程服务上执行命令\n\n如果需要在远程 redis 服务上执行命令，同样我们使用的也是 **redis-cli** 命令。\n\n#### 语法\n\n```\n$ redis-cli -h host -p port -a password\n```\n\n#### 实例\n\n以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。\n\n```\n$redis-cli -h 127.0.0.1 -p 6379 -a \"mypass\"\nredis 127.0.0.1:6379>\nredis 127.0.0.1:6379> PING\n\nPONG\n```\n\n# Redis 键(key)\n\nRedis 键命令用于管理 redis 的键。\n\n### 语法\n\nRedis 键命令的基本语法如下：\n\n```\nredis 127.0.0.1:6379> COMMAND KEY_NAME\n```\n\n### 实例\n\n```\nredis 127.0.0.1:6379> SET runoobkey redis\nOK\nredis 127.0.0.1:6379> DEL runoobkey\n(integer) 1\n```\n\n在以上实例中 **DEL** 是一个命令， **runoobkey** 是一个键。 如果键被删除成功，命令执行后输出 **(integer) 1**，否则将输出 **(integer) 0**\n\n## Redis keys 命令\n\n下表给出了与 Redis 键相关的基本命令：\n\n| 序号   | 命令及描述                                    |\n| ---- | ---------------------------------------- |\n| 1    | [DEL key](http://www.runoob.com/redis/keys-del.html)该命令用于在 key 存在时删除 key。 |\n| 2    | [DUMP key](http://www.runoob.com/redis/keys-dump.html) 序列化给定 key ，并返回被序列化的值。 |\n| 3    | [EXISTS key](http://www.runoob.com/redis/keys-exists.html) 检查给定 key 是否存在。 |\n| 4    | [EXPIRE key](http://www.runoob.com/redis/keys-expire.html) seconds为给定 key 设置过期时间。 |\n| 5    | [EXPIREAT key timestamp](http://www.runoob.com/redis/keys-expireat.html) EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 |\n| 6    | [PEXPIRE key milliseconds](http://www.runoob.com/redis/keys-pexpire.html) 设置 key 的过期时间以毫秒计。 |\n| 7    | [PEXPIREAT key milliseconds-timestamp](http://www.runoob.com/redis/keys-pexpireat.html) 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 |\n| 8    | [KEYS pattern](http://www.runoob.com/redis/keys-keys.html) 查找所有符合给定模式( pattern)的 key 。 |\n| 9    | [MOVE key db](http://www.runoob.com/redis/keys-move.html) 将当前数据库的 key 移动到给定的数据库 db 当中。 |\n| 10   | [PERSIST key](http://www.runoob.com/redis/keys-persist.html) 移除 key 的过期时间，key 将持久保持。 |\n| 11   | [PTTL key](http://www.runoob.com/redis/keys-pttl.html) 以毫秒为单位返回 key 的剩余的过期时间。 |\n| 12   | [TTL key](http://www.runoob.com/redis/keys-ttl.html) 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 |\n| 13   | [RANDOMKEY](http://www.runoob.com/redis/keys-randomkey.html) 从当前数据库中随机返回一个 key 。 |\n| 14   | [RENAME key newkey](http://www.runoob.com/redis/keys-rename.html) 修改 key 的名称 |\n| 15   | [RENAMENX key newkey](http://www.runoob.com/redis/keys-renamenx.html) 仅当 newkey 不存在时，将 key 改名为 newkey 。 |\n| 16   | [TYPE key](http://www.runoob.com/redis/keys-type.html) 返回 key 所储存的值的类型。 |\n\n更多命令请参考：<https://redis.io/commands>",[[1521131234786,["wanghuan@DESKTOP-VT81TGT",[[1,0,"\n"]],[0,0],[1,1]]],[1521131235605,["wanghuan@DESKTOP-VT81TGT",[[1,0,"---\ntitle: Redis数据类型\ndate: 2018/3/15 20:46:25\ncategory:\n- redis\ntag:\n- redis\ncomments: true  \n---"]],[0,0],[97,97]]],[1521131242338,["wanghuan@DESKTOP-VT81TGT",[[-1,16,"数据类型"],[1,20," 简介"]],[11,20],[19,19]]]]],["5d20cd51-2391-4ce9-9694-5e4ed3380f9c",1521131358076,"---\ntitle: Redis 简介\ndate: 2018/3/15 20:46:25\ncategory:\n- redis\ntag:\n- redis\ncomments: true  \n---\n# Redis 简介\n\nRedis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。\n\nRedis 与其他 key - value 缓存产品有以下三个特点：\n\n- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n- Redis支持数据的备份，即master-slave模式的数据备份。\n\n>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：\n>\n>- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。\n>- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。\n>- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。\n>\n>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。\n>\n>很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。\n\n### Redis 优势\n\n- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n- 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\n- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n### Redis与其他key-value存储有什么不同？\n\n- Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\n- Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n\n\n\n\n\n\n## Redis 数据类型\n\nRedis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n\n\n### String（字符串）\n\nstring是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。\n\nstring类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。\n\nstring类型是Redis最基本的数据类型，一个键最大能存储512MB。\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> SET name \"runoob\"\nOK\nredis 127.0.0.1:6379> GET name\n\"runoob\"\n```\n\n在以上实例中我们使用了 Redis 的 **SET** 和 **GET** 命令。键为 name，对应的值为 **runoob**。\n\n**注意：**一个键最大能存储512MB。\n\n\n### Hash（哈希）\n\nRedis hash 是一个键名对集合。\n\nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。\n\n#### 实例\n\n```\n127.0.0.1:6379> HMSET user:1 username runoob password runoob points 200\nOK\n127.0.0.1:6379> HGETALL user:1\n1) \"username\"\n2) \"runoob\"\n3) \"password\"\n4) \"runoob\"\n5) \"points\"\n6) \"200\"\n```\n\n以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis **HMSET, HGETALL** 命令，**user:1** 为键值。\n\n每个 hash 可以存储 2\n\n32\n\n -1 键值对（40多亿）。\n\n### List（列表）\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> lpush runoob redis\n(integer) 1\nredis 127.0.0.1:6379> lpush runoob mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush runoob rabitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange runoob 0 10\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n\n### Set（集合）\n\nRedis的Set是string类型的无序集合。\n\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\n\n#### sadd 命令\n\n添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0,key对应的set不存在返回错误。\n\n```\nsadd key member\n```\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> sadd runoob redis\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob rabitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob rabitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers runoob\n\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\n```\n\n**注意：**以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。\n\n集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。\n\n### zset(sorted set：有序集合)\n\nRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。\n\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\n\nzset的成员是唯一的,但分数(score)却可以重复。\n\n#### zadd 命令\n\n添加元素到集合，元素在集合中存在则更新对应score\n\n```\nzadd key score member \n```\n\n#### 实例\n\n```\nredis 127.0.0.1:6379> zadd runoob 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 rabitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 rabitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE runoob 0 1000\n\n1) \"redis\"\n2) \"mongodb\"\n3) \"rabitmq\"\n```\n\n\n## Redis 命令\n\nRedis 命令用于在 redis 服务上执行操作。\n\n要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。\n\n### 语法\n\nRedis 客户端的基本语法为：\n\n```\n$ redis-cli\n```\n\n### 实例\n\n以下实例讲解了如何启动 redis 客户端：\n\n启动 redis 客户端，打开终端并输入命令 **redis-cli**。该命令会连接本地的 redis 服务。\n\n```\n$redis-cli\nredis 127.0.0.1:6379>\nredis 127.0.0.1:6379> PING\n\nPONG\n```\n\n在以上实例中我们连接到本地的 redis 服务并执行 **PING** 命令，该命令用于检测 redis 服务是否启动。\n\n### 在远程服务上执行命令\n\n如果需要在远程 redis 服务上执行命令，同样我们使用的也是 **redis-cli** 命令。\n\n#### 语法\n\n```\n$ redis-cli -h host -p port -a password\n```\n\n#### 实例\n\n以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。\n\n```\n$redis-cli -h 127.0.0.1 -p 6379 -a \"mypass\"\nredis 127.0.0.1:6379>\nredis 127.0.0.1:6379> PING\n\nPONG\n```\n\n# Redis 键(key)\n\nRedis 键命令用于管理 redis 的键。\n\n### 语法\n\nRedis 键命令的基本语法如下：\n\n```\nredis 127.0.0.1:6379> COMMAND KEY_NAME\n```\n\n### 实例\n\n```\nredis 127.0.0.1:6379> SET runoobkey redis\nOK\nredis 127.0.0.1:6379> DEL runoobkey\n(integer) 1\n```\n\n在以上实例中 **DEL** 是一个命令， **runoobkey** 是一个键。 如果键被删除成功，命令执行后输出 **(integer) 1**，否则将输出 **(integer) 0**\n\n## Redis keys 命令\n\n下表给出了与 Redis 键相关的基本命令：\n\n| 序号   | 命令及描述                                    |\n| ---- | ---------------------------------------- |\n| 1    | [DEL key](http://www.runoob.com/redis/keys-del.html)该命令用于在 key 存在时删除 key。 |\n| 2    | [DUMP key](http://www.runoob.com/redis/keys-dump.html) 序列化给定 key ，并返回被序列化的值。 |\n| 3    | [EXISTS key](http://www.runoob.com/redis/keys-exists.html) 检查给定 key 是否存在。 |\n| 4    | [EXPIRE key](http://www.runoob.com/redis/keys-expire.html) seconds为给定 key 设置过期时间。 |\n| 5    | [EXPIREAT key timestamp](http://www.runoob.com/redis/keys-expireat.html) EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 |\n| 6    | [PEXPIRE key milliseconds](http://www.runoob.com/redis/keys-pexpire.html) 设置 key 的过期时间以毫秒计。 |\n| 7    | [PEXPIREAT key milliseconds-timestamp](http://www.runoob.com/redis/keys-pexpireat.html) 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 |\n| 8    | [KEYS pattern](http://www.runoob.com/redis/keys-keys.html) 查找所有符合给定模式( pattern)的 key 。 |\n| 9    | [MOVE key db](http://www.runoob.com/redis/keys-move.html) 将当前数据库的 key 移动到给定的数据库 db 当中。 |\n| 10   | [PERSIST key](http://www.runoob.com/redis/keys-persist.html) 移除 key 的过期时间，key 将持久保持。 |\n| 11   | [PTTL key](http://www.runoob.com/redis/keys-pttl.html) 以毫秒为单位返回 key 的剩余的过期时间。 |\n| 12   | [TTL key](http://www.runoob.com/redis/keys-ttl.html) 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 |\n| 13   | [RANDOMKEY](http://www.runoob.com/redis/keys-randomkey.html) 从当前数据库中随机返回一个 key 。 |\n| 14   | [RENAME key newkey](http://www.runoob.com/redis/keys-rename.html) 修改 key 的名称 |\n| 15   | [RENAMENX key newkey](http://www.runoob.com/redis/keys-renamenx.html) 仅当 newkey 不存在时，将 key 改名为 newkey 。 |\n| 16   | [TYPE key](http://www.runoob.com/redis/keys-type.html) 返回 key 所储存的值的类型。 |\n\n更多命令请参考：<https://redis.io/commands>",[[1521131308699,["wanghuan@DESKTOP-VT81TGT",[[-1,1283,"\n"]],[1278,1278],[1278,1278]]],[1521131308882,["wanghuan@DESKTOP-VT81TGT",[[-1,1282,"\n"]],[1278,1278],[1278,1278]]],[1521131309138,["wanghuan@DESKTOP-VT81TGT",[[-1,1281,"\n"]],[1278,1278],[1278,1278]]],[1521131309393,["wanghuan@DESKTOP-VT81TGT",[[-1,1280,"\n"]],[1278,1278],[1278,1278]]],[1521131309656,["wanghuan@DESKTOP-VT81TGT",[[-1,1279,"\n"]],[1278,1278],[1278,1278]]],[1521131310106,["wanghuan@DESKTOP-VT81TGT",[[-1,1278,"\n"]],[1278,1278],[1278,1278]]]]]]}