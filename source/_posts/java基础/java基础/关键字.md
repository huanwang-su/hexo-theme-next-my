---
title: java 关键字
date: 2018/3/16 08:28:25
category:
- java基础
- java基础
tag:
- nio 
comments: true  
---
## static ##
static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块
被static修饰的成员变量和成员方法独立于该类的任何对象,属于这个类。
### 静态变量和实例变量 ###
　　对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便）。<br>
　　对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 <br>
　　所以一般在需要实现以下两个功能时使用静态变量：1.在对象之间共享值时  2.方便访问变量时
### 静态方法 ###
　　静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。
### static代码块 ###
　　static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。
### 内部静态类 ###

参考内部类中的静态嵌套类

## final ##
final数据:向编译器告知一块数据恒定不变,基本类型数值不变,引用类型引用不变

final参数:无法更改参数引用所指向的对象

final方法:锁定方法,继承类无法修改它的含义. private方法默认是final的 

final类: 禁止继承该类

static final:全局常量
> **传值和传引用** <br>
> 传的是参数的一份拷贝,无论是简单数据类型还是引用<br>
> 对于参数传递，如果是简单数据类型，那么它传递的是值拷贝，对于类的实例它传递的是类的引用。需要注意的是，这条规则只适用于参数传递。

----------
## 抽象类和接口 ##
抽象方法:只有声明没有方法体,抽象方法必须为public或者protected,默认是public

	abstract void f();
抽象类:包含抽象方法的类叫做抽象类.抽象类不能用来创建对象

	abstract class C{};
接口:interface,一个完全抽象类,没有提供任何具体实现,只提供形式,接口方法是public的,实现它必须是public

> 接口冲突:编译报错<br>
> 继承可以扩展接口<br>
> 接口中可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量），而方法会被隐式地指定为public abstract方法且只能是public abstract方法,接口中的方法必须都是抽象方法
 
区别:

1. 语法层面上的区别<br>
　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>
　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>
　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>
　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2. 设计层面上的区别<br>
　　1) 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br>
　　2)抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范。对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

>因为继承多个有实现的类容易出现菱形继承的问题，即，两个父类继承自同一个基类，则子类中会包含两份祖父类的内容，不合并重复内容会引起一些歧义，而合并重复内容又会导致类成员的内存布局不能简单复制地从父类复制。

## 内部类 ##
**成员内部类**

成员内部类是最普通的内部类，它的定义为位于另一个类的内部

内部类拥有其外围类的所有元素的访问权. 在拥有外部类对象前是不可能创建内部类对象的<br>

.this和.new

- 内部类对外部类对象的引用: 外部类名.this
- 外部类对象创建内部类对象: 外部类对象.new 外部类名.内部类名();
>编译器会默认为成员内部类添加了一个指向外部类对象的引用
>
>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问

**局部内部类**

局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。不能有public、protected、private以及static修饰符的。

**匿名内部类**<br>
　　创建一个继承自XXX类的匿名类的对象<br>
　　匿名内部类引用外部变量是必须声明是final的

**静态内部类**<br>
如果不需要内部类对象与外部类对象有关系,可以将内部类声明为static,在静态嵌套类内部，不能访问外部类的非静态成员

区别:

- 静态内部类不能访问其外部类的非静态成员变量和方法
- 在非静态内部类中不可以声明静态成员
- 创建静态类内部对象时，不需要其外部类的对象

**作用**<br>

- java中的内部类和接口加在一起，可以实现多继承。()
- 可以使某些编码根简洁。(匿名内部类)
- 隐藏你不想让别人知道的操作。
>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问<br>
>多继承即用多个内部类继承多个父类,外部类添加内部类引用,就可以实现外部类调用多个父类,也就是多继承

## transient ##

我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，Java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个的所有属性和方法都会自动序列化。

如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程.换句话说，这个字段的生命周期仅存于调用者的内存中。
