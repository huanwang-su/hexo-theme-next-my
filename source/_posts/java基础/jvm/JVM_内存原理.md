---
title: jvm虚拟机内存原理
date: 2018/3/16 08:28:25
category:
- java基础
- jvm
tag:
- jvm
comments: true  
---

## Jvm运行时，内存划分如图所示 ##

![](http://static.oschina.net/uploads/space/2015/0604/172608_5h77_1378920.jpg)

### 程序计数器 ###
Jvm将这个计数看作当前线程执行某条字节码的行数，会根据计数器的值来选取需要执行的操作语句。这个属于线程私有，不可共享，如果共享会导致计数混乱，无法准确的执行当前线程需要执行的语句

### 虚拟机栈 ###
经常说到的栈内存就是指虚拟机栈。Java中每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 

### 本地方法栈 ###
虚拟机栈用来执行java方法，而本地方法栈用来执行Native方法。抛出异常的情况和虚拟机栈一样。 

### 堆 ###
是jvm中内存最大、线程共享的一块区域。唯一的目的是存储对象实例。这里也是垃圾收集器主要收集的区域。由于现代垃圾收集器都采用的是分代收集算法，所以java堆也分为新生代和老年代。 

可以通过参数-Xmx(jvm最大可用内存)和-Xms(jvm初始内存)来调整堆内存，如果扩大至无法继续扩展时，会出现OutOfMemoryError的错误。 

### 方法区 ###
Jvm中内存共享的一片区域，用来存储类信息、常量、静态变量、class文件。垃圾收集器也会对这部分区域进行回收，比如常量池的清理和类型的卸载，但是效果不理想。方法区内存不够用的时候，也会抛出OutOfMemoryError错误。

## 对象 ##
### 创建 ###
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，加载检查之后会在堆中划分出一定的内存。 

在完成new指令之后，紧接着会调用<init>方法将对象初始化，这时一个完整的对象才算创建了出来。 

### 对象的访问 ###
![](http://static.oschina.net/uploads/space/2015/0604/172655_ZLLb_1378920.jpg)

## 异常 ##
### OutOfMemoryError错误  ###
Java堆内存的OutOfMemoryError异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。 

当产生的对象过多时，会出现这个错误信息。解决办法：调整虚拟机堆参数(-Xmx和-Xms)。 

Java方法区会存储类信息、常量、静态变量等。如果产生了大量类，比如某个ssh项目因为加载了框架和大量jar包，这样class文件都会载入内存的方法区，这样如果出现内存无法继续扩展的情况，也会出现java.lang.OutOfMemoryError，然后紧跟着PermGen space信息。通过-XX:PermSize和-XX:MaxPermSize可以限制方法区大小。 

### StackOverflow错误  ###

Java中栈内存溢出，通常是由于栈深度超过限制深度，导致出现该问题。很常见的情况是，使用递归的时候，不小心忘了指定递归结束的时刻，导致递归深度超过限制深度，出现栈内存溢出。 

## 内存回收机制 ##
Java内存运行时区域的各个部分，其中程序计数器、VM栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的帧随着方法进入、退出而有条不紊的进行着出栈入栈操作。而Java堆和方法区（包括运行时常量池）则不一样，我们必须等到程序实际运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的。

### 判断对象已死 ###

**1)引用计数算法**

引用计数算法无法解决对象循环引用的问题。

根搜索算法（通过一系列的称为“GCRoots”的点作为起始进行向下搜索，当一个对象到GCRoots没有任何引用链（ReferenceChain）相连，则证明此对象是不可用的）GC Roots包括：

1. 在VM栈（帧中的本地变量）中的引用。
2. 方法区中的静态引用和常量引用的对象。
3. JNI（即一般说的Native方法）中的引用。

**2)生存还是死亡？**

判定一个对象死亡，至少经历两次标记过程：如果对象在进行根搜索后，发现没有与GC Roots相连接的引用链，那它将会被第一次标记，并在稍后执行他的finalize()方法（如果它有的话）。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。 finalize()方法是对象最后一次逃脱死亡命运的机会，稍后GC将进行第二次规模稍小的标记，如果在finalize()中对象成功拯救自己（只要重新建立到GC Roots的连接即可，譬如把自己赋值到某个引用上），那在第二次标记时它将被移除出“即将回收”的集合，如果对象这时候还没有逃脱，那基本上它就真的离死不远了。需要关闭外部资源之类的事情，基本上它能做的使用try-finally可以做的更好。

**3)回收方法区**

方法区即后文提到的永久代，这区GC的“性价比”一般比较低：在堆中，尤其是在新生代，进行一次GC可以一般可以回收70%~95%的空间，而永久代的GC效率远小于此。目前方法区主要回收两部分内容：废弃常量与无用类。需要满足下面3个条件：

1. 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例
2. 加载该类的ClassLoader已经被GC。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。

## 垃圾收集算法 ##

### 标记－清除算法（Mark-Sweep） ###
首先标记出所有需要回收的对象，然后回收所有需要回收的对象。主要缺点有两个，一是效率问题，标记和清理两个过程效率都不高，二是空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作。

### 复制算法（Copying）(新生代) ###
将内存分为一块较大的eden空间和2块较少的survivor空间，每次使用eden和其中一块survivor，当回收时将eden和 survivor还存活的对象一次过拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor。复制收集算法在对象存活率高的时候，效率有所下降。

HotSpot默认eden:survivor是8:1,当survivor空间不够时,会分配老生代中

### 标记－整理（Mark-Compact）(老生代)算法 ###

标记过程仍然一样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存。
分代收集(Generational Collection)算法

### 分代收集(Generational Collection)算法 ###
此算法只是根据对象不同的存活周期将内存划分为几块。一般是把Java堆分作新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

