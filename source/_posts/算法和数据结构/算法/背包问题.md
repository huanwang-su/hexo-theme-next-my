---
title: 背包问题
date: 2018/3/16 08:28:25
category:
- 算法和数据结构
- 算法
tag:
- 背包问题
comments: true  
---

## 01背包 ##
### 题目 ###
有N件物品和一个容量为V 的背包。放入第i件物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。
### 基本思路 ###
特点：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即F[i,v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：

	F[i,v] = max{F[i-1,v] , F[i-1,v-Ci]+Wi}

如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为F[i-1,v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，此时能获得的最大价值就是F[i-1; v-Ci]再加上通过放入第i件物品获得的价值Wi。

伪代码如下：
	
	F[0,0..V]=0
	for i=1..N 
		for v=c[i]..V
			F[i,v]=max{f[i-1,v],f[i-1,v-c[i]]+w[i]};

### 优化空间复杂度 ###
	F[0,0..V]=0
	for i=1..N
    	for v=V..c[i]
        	f[v]=max{f[v],f[v-c[i]]+w[i]};

f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，在每次主循环中我们以v=V..0的顺序推f[v]，能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。
> 当v=v'时, 此时的f中 >v' 保留的是计算了i物品后的最大价值, <=v' 保留的是计算了i-1物品后的最大价值

### 求解路径 ###
1. 非优化空间的
  
	for(i=N,j=V;i>0,j>0;i--) 
		if(F[i][j]=F[i-1][j-C[i]]+W[i]){ 
			Print W[i]  
			j←j-C[i]
		}

2. 优化后

	没想到好办法, 类似与非优化的, 也是O(NV)

### 初始化细节 ###

1. 恰好装满背包<br> 
在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。
2. 只希望价格尽量大<br> 
初始化时应该将f[0..V]全部设为0。

>初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有剩余容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0
>
>必须满情况下装不满, 则该值为-∞

## 完全背包 ##
### 问题 ###
有N种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第i种物品的耗费的空间是Ci，得到的价值是Wi。求解：将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。
### 基本思路 ###
这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……直至取⌊V /Ci⌋件等很多种。

简单改进01背包的状态转移方程:f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]}

但是我们用:

	for i=1..N
	    for v=c[i]..V
	        f[v]=max{f[v],f[v-c[i]]+w[i]};

这个和01背包很像,只是v的顺序倒置了,思考:如果是V..0, 则第i件物品只用了一次,因为<=v'保留的是计算了i-1物品后的最大价值;如果是0..V,<=v'的最大容量中第i个物品可能多次利用,即第二重循环为多次加入第i个物品后的最优解

## 多重背包问题 ##
### 问题 ###
有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
  
### 基本思路 ###
和完全背包类似: f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i] | 0<=k<=n[i]}复杂度是O(V*Σn[i])。

转化为01背包问题<br>
我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略取0..n[i]件均能等价于取若干件代换以后的物品。

方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*Σlog n[i])的01背包问题

伪代码:

	//表示处理一件01背包中的物品
	procedure ZeroOnePack(cost,weight)		
	    for v=V..cost
	        f[v]=max{f[v],f[v-cost]+weight}

	//处理一件完全背包类物品
	procedure CompletePack(cost,weight)
	    for v=cost..V
	        f[v]=max{f[v],f[v-c[i]]+w[i]}

	//多重背包
	procedure MultiplePack(cost,weight,amount)
	    if cost*amount>=V
	        CompletePack(cost,weight)        //完全背包
	        return
	    integer k=1
	    while k<num
	        ZeroOnePack(k*cost,k*weight)	 //01背包
	        amount=amount-k
	        k=k*2
	    ZeroOnePack(amount*cost,amount*weight) //01背包


## 混合三种背包问题 ##
有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）

	for i=1..N
	    if 第i件物品是01背包
	        ZeroOnePack(c[i],w[i])
	    else if 第i件物品是完全背包
	        CompletePack(c[i],w[i])
	    else if 第i件物品是多重背包
	        MultiplePack(c[i],w[i],n[i])

## 二维费用的背包问题 ##
### 问题 ###
二维费用的背包问题是指：对于每件物品，具有两种不同的空间耗费，选择这件物品必须同时付出这两种代价。对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。

### 分析 ###
费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：

	f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}
可以转化为二维的, 把i取掉, 类似一维

## 分组的背包问题 ##
### 问题 ###
有N件物品和一个容量为V的背包。第i件物品的费用是Ci，价值是Wi。这些物品被划分为K组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

### 分析 ###
这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有：

	f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}
代码:

	for 所有的组k
	    for v=V..0
	        for 所有的i属于组k
	            f[v]=max{f[v],f[v-c[i]]+w[i]}
注意这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。
>当v=v'时, 第三重循环会按最大值进行替换k中的i, 因为是替换, 所以k中只有一个元素添加进来
>
>如果二三重循环互换, 和01背包没区别

## 有依赖的背包问题 ##
### 问题 ###
这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品i依赖于物品j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。

