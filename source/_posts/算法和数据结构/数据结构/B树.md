---
title: B树
date: 2018/3/16 08:28:25
category:
- 算法和数据结构
- 数据结构
tag:
- B树
comments: true  
---

参考:

1. **[http://blog.csdn.net/hguisu/article/details/7786014](http://blog.csdn.net/hguisu/article/details/7786014)**
2. **[http://blog.csdn.net/v_JULY_v/article/details/6530142/](http://blog.csdn.net/v_JULY_v/article/details/6530142/)**
3. **[http://blog.csdn.net/swordmanwk/article/details/6549480](http://blog.csdn.net/swordmanwk/article/details/6549480)**
4. **算法导论**

## B树 ##
B树是为磁盘或其他直接存取的辅助设备而设计的一种平衡搜索树, 类似于红黑树, 但是在降低IO方面做的更好一些
### 定义 ###
B树是一种平衡的多路查找树，它在文件系统和数据库中很有用。

**定义**：

1. B树内的每一个节点x都具有以下字段：<br>
	- 当前存储在节点x中的关键字（key）个数n[x]。
	- 存储在x节点中的n[x]个关键字是以非降序的顺序排列的，即：key1[x] ≤key2[x]......≤keyn[x][x]。
	- 一个表示x节点否是叶节点的bool值leaf[x]。
2. 每个内节点拥有指向n[x]+1个指向叶节点的指针，c1[x]，c2[x]......cn[x]+1[x]。叶节点没有ci[x]域
3. 节点x的key值，将子节点的key值范围分开了。如果ki是ci[x]指向的子节点的任意一个key的值，那么有：k1 ≤ key1[x] ≤ k2 ≤ key2[x] ≤ ≤ keyn[x][x] ≤ kn[x]+1.
4. 所有的叶节点具有相同的深度，这个深度也就是树高h。
5. 一个节点可容纳的关键字数目是有上下限的。这个界限可以用包含一个大于2的整数t的表达式来表示，这个数t称为B树的最小度。

>除根节点外，每个节点至少要包含t-1个关键字（key），每个内节点（除根外）至少要包含t个关键字。一棵非空的B树，根节点至少要包含一个key。
每个节点最多包含2t-1个关键字，因此，内节点最多有2t个子节点。对于一个包含2t-1个关键的节点，我们就称这个节点满了。


![](http://my.csdn.net/uploads/201207/28/1343441845_4081.jpg)

以子树c为例,n=2,[43,78]为关键码,其他为指向节点的指针

### B树的高度 ###
h<logt(n+1/2)

### Node数据结构 ###
	typedef int KeyType ;  
	#define m 5                 /*B 树的阶，暂设为5*/  
	typedef struct Node{  
	    int keynum;             /* 结点中关键码的个数，即结点的大小*/  
	    struct Node *parent;    /*指向双亲结点*/   
	    KeyType key[m+1];       /*关键码向量，0 号单元未用*/   
	    struct Node *ptr[m+1];  /*子树指针向量*/   
	    Record *recptr[m+1];    /*记录指针向量*/  
	}NodeType;                  /*B 树结点类型*/  

### 查找 ###
显然, B-树也是一种有序的结构,可以类似二叉查找树查找. 一般先在关键字中找, 没有则到子树中找, 

	B-TREE-SEARCH(x, k)				      //在x中查找k
	1 i = 1
	2 while i <= x.n and k >= x.keyi      //在关键字中查找k
	3 	i = i + 1
	4 if i <= x.n and k == x.keyi		  //在key[]中
	5 	return (x,i)
	6 elseif x.leaf						  //key[]中没有且如果是叶节点
	7 	return NIL
	8 else DISK-READ(x.ci)				  //子节点中找
	9 	return B-TREE-SEARCH(x.ci, k)


从查找算法中可以看出， 在B-树中进行查找包含两种基本操作:

1. 在B树关键字中查找；
2. 在结点中查找关键字。

由于B树通常存储在磁盘上， 则前一查找操作是在磁盘上进行的， 而后一查找操作是在内存中进行的，即在磁盘上找到指针p 所指结点后， 先将结点中的信息读入内存， 然后再利用顺序查找或折半查找查询等于K 的关键字。显然， 在磁盘上进行一次查找比在内存中进行一次查找的时间消耗多得多.

### 创建空树 ###
	B-TREE-CREATE(T)
	1 x = ALLOCATE-NODE()
	2 x.leaf = TRUE
	3 x.n = 0
	4 DISK-WRITE(x)
	5 T.root = x 

### 分裂 ###
分裂是树长高的唯一途径

![](http://i.imgur.com/UkqM9yv.png)

x是非满的节点, i指向x.ci的节点,该节点为满,满树有2t-1个关键字, 提最中间的关键字, 生成两个节点

![](http://i.imgur.com/OiwmS8i.png)

### 插入 ###
单行程向下插入, 根满了就分裂, 保证不满,提中间元素为根, 再调用非满的插入函数

![](http://i.imgur.com/iPY4J00.png)

### 非满插入函数 ###
插入最终是在叶子节点上

3~7 插入关键字

9~17 尾递归的找到叶节点, 注意路径中非叶节点满则分裂, 保证尾递归的正确, 也是单行程向下插入

![](http://i.imgur.com/EuxyeFb.png)
### 插入例子 ###
t=3, 关键字[2,5] ,节点[3,6]

![](http://i.imgur.com/nkOreu9.png)

<hr>
### 删除 ###
与插入情况相对称，除了根结点外（根结点个数不能少于1），B树的关键字数不能少于t-1个。对于简单删除情况，如果我们定位到关键字处在某个结点中，如果这个结点中关键字个数恰好是t-1个，如果直接删除这个关键字，就会违反B树规则。

此时，需要考虑两种处理方案：

1. 把这个结点与其相邻结点合并，合并时需要把父结点的一个关键字加进来，除非相邻的那个结点的关键字数也是t-1个，否则，合并后会超出2t-1的限制，同样违反B树规则。而且，因为从父结点拉下一个关键字，导致父结点的关键字数少1，如果原来父结点关键字数是t-1，那么父结点违反B树规则，这种情况下，必须进行回溯处理。（对于下图（a）初始树，删除结点Z就会出现这种情况）
2. 从相邻结点借一个关键字过来，这种情况要求，相邻结点必须有多于t-1个关键字，借的过程中，需要转经父结点，否则违反B树规则。
 
为了避免回溯，要求我们在从树根向下搜索关键字的过程中，凡是遇到途经的结点，如果该结点的关键字数是t-1，则我们需要想办法从其他地方搞个关键字过来，使得该结点的关键字数至少为t。

搞，也是从相邻结点搞，如果相邻结点有的话，当然，也要经过父结点进行周转。如果没有，就说明相邻结点的关键字个数也是t-1，这种情况，直接对该结点与其相邻结点进行合并，以满足要求。

代码参考**[http://blog.csdn.net/swordmanwk/article/details/6549480](http://blog.csdn.net/swordmanwk/article/details/6549480)**

### 删除例子 ###
t=3, 关键字[2,5] ,节点[3,6]

![](http://i.imgur.com/jO6vxtO.png)

![](http://i.imgur.com/Cx42Aki.png)

### 思考 ###
插入路过的每个节点都非满, 删除路过的每个节点都非t-1, 根节点除外

1. 插入非满保证在叶子节点插入时, 如果叶子节点满了, 则向父节点添加一个关键字, 若路过的每个节点都非满可以保证不用向上回溯
2. 删除同理, 如果要删除的点关键子数为 t-1, 只能向兄弟借, 兄弟借不到就要合并点, 合并后父少个节点, 不满足, 回溯的满足父亲, 不是单向的 

## B+树 ##
与B树区别

1. 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。
通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
   
![](http://e.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=4e646f941f178a82da3177f2976a18e8/902397dda144ad3495c012dfd1a20cf431ad856f.jpg)

### B+树与操作系统的文件索引和数据库索引 ###
为什么说B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引？
 
- **B+树的磁盘读写代价更低**: B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。
- **B+树的查询效率更加稳定**: 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## B*树 ##
是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B\*树定义了非叶子结点关键字个数至少为(2/3)\*M，即块的最低使用率为2/3（代替B+树的1/2）；

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B\*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

所以，B\*树分配新结点的概率比B+树要低，空间使用率更高；