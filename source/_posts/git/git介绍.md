---
title: git介绍
date: 2018/3/16 14:55:00
category:
- git
tag:
- git
comments: true  
---


## 版本控制

版本控制是一种记录一个或若干文件内容变化， 以便将来查阅特定版本修订情况的系统。

采用版本控制系统（VCS）可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态， 你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的 原因，又是谁在何时报告了某个功能缺陷等等。

- **本地版本控制系统**

  大多都是采用某种简 单的数据库来记录文件的历次更新差异。

- **集中化的版本控制系统**

  诸如 CVS、Subversion	以及Perforce	等，都有一个单一的集中管理的服务器，保存所有文件的修 订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 

- **分布式版本控制系统**

  客户端并不只提取最新版本的文件快 照，而是把代码仓库完整地镜像下来。，任何一处协同工作用的服务器发生故障， 事后都可以用任何一个镜像出来的本地仓库恢复。	因为每一次的克隆操作，实际上都是一次 对代码仓库的完整备份。

## Git	基础

特点：

- 直接记录快照，而非差异比较

- 近乎所有操作都是本地执行

  在	Git	中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的 信息。

- Git	保证完整性

  Git	中所有数据在存储前都计算校验和，然后以校验和来引用。

### 三种状态：

- **已提交（committed）**数据已经安全的保存在本地数据库中。
- **已修改（modified）**表示修改了文件，但 还没保存到数据库中。
- **已暂存 （staged）** 对一个已修改文件的当前版本做了标记，使之包含在下次 提交的快照中。

三个工作区域的概念：Git	仓库、工作目录以及暂存区域

![img](https://gitee.com/progit/figures/18333fig0106-tn.png) 

- Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。从其它计算机克隆仓库时，拷贝的就是这里的数据。
- 工作目录是对项目的某个版本独立提取出来的内容。放在磁盘上供你使用或修改。
- 暂存区域是一个文件，保存了下次将提交的文件列表信息

基本的	Git	工作流程如下：

1.	在工作目录中修改文件。
2.	暂存文件，将文件的快照放入暂存区域。
3.	提交更新，找到暂存区域的文件，将快照永久性存储到	Git	仓库目录。

### 获取Git仓库

#### 在现有目录中初始化仓库

只需到此项目所在的目录，执行：

```
$ git init
```

如果当前目录下有几个文件想要纳入版本控制，需要先用 `git add` 命令告诉 Git 开始对这些文件进行跟踪，然后提交：

```
$ git add *.c
$ git add README
$ git commit -m 'initial project version'
```

#### 从现有仓库克隆

```
$ git clone git://github.com/schacon/grit.git
```

这会在当前目录下创建一个名为`grit`的目录，其中包含一个 `.git` 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：

```
$ git clone git://github.com/schacon/grit.git mygrit
```

### 记录每次更新到仓库

工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪

在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。

![img](https://gitee.com/progit/figures/18333fig0201-tn.png) 

#### 检查当前文件状态

```bash
$ git status
    # On branch master
    # Untracked files:
    # (use "git add <file>..." to include in what will be committed)
    #
    # README
    nothing added to commit but untracked files present (use "git add" to track)
```

在状态报告中可以看到新建的`README`文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。不过现在的例子中，我们确实想要跟踪管理 README 这个文件。

#### 跟踪新文件

```
$ git add README
```

#### 暂存已修改文件

```
$ git add benchmarks.rb
```

 `git add` 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）

#### 忽略某些文件

名为 `.gitignore` 的文件，列出要忽略的文件模式。

文件 `.gitignore` 的格式规范如下：

- 所有空行或者以注释符号 `＃` 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。
- 匹配模式最后跟反斜杠（`/`）说明要忽略的是目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（`!`）取反。

 glob 模式是指 shell 所使用的简化了的正则表达式。星号（`*`）匹配零个或多个任意字符；`[abc]` 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（`?`）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 `[0-9]` 表示匹配所有 0 到 9 的数字）。

#### 查看已暂存和未暂存的更新

查看尚未暂存的文件更新了哪些部分，不加参数直接输入 `git diff`

要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 `git diff --cached` 命令

请注意，单单 `git diff` 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。所以有时候你一下子暂存了所有更新过的文件后，运行 `git diff` 后却什么也没有，就是这个原因。

#### 提交更新

现在的暂存区域已经准备妥当可以提交了。提交的时候不会记录这些还没暂存起来的变化

```bash
$ git commit -m "Story 182: Fix benchmarks for speed"
```

记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。

#### 跳过使用暂存区域

尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤：

```
$ git commit -a -m 'added new benchmarks'
```

#### 移除文件

要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。

 `git rm` 命令完成此项工作，并连带从工作目录中删除指定的文件

```
$ git rm grit.gemspec
```

最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 `-f`（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。

把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。

```
$ git rm --cached readme.txt
```

后面可以列出文件或者目录的名字，也可以使用 glob 模式。

#### 移动文件

Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。

```
$ git mv file_from file_to
```

### 查看提交历史

`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。

`-p` 选项展开显示每次提交的内容差异，用 `-2` 则仅显示最近的两次更新

```bash
选项 说明
    -p 按补丁格式显示每个更新之间的差异。
    --stat 显示每次更新的文件修改统计信息。
    --shortstat 只显示 --stat 中最后的行数修改添加移除统计。
    --name-only 仅在提交信息后显示已修改的文件清单。
    --name-status 显示新增、修改、删除的文件清单。
    --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。
    --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。
    --graph 显示 ASCII 图形表示的分支合并历史。
    --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。
```



### 撤消操作

#### 修改最后一次提交

使用 `--amend` 选项重新提交：

```
$ git commit --amend
```

此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。

#### 取消已经暂存的文件

```
$ git reset HEAD benchmarks.rb
```

#### 取消对文件的修改

```
$ git checkout -- benchmarks.rb
```

这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。

### 远程仓库的使用

同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。

#### 查看当前的远程库

 `git remote` 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：

```bash
$ git remote -v
    bakkdoor git://github.com/bakkdoor/grit.git
    cho45 git://github.com/cho45/grit.git
    defunkt git://github.com/defunkt/grit.git
    koke git://github.com/koke/grit.git
    origin git@github.com:mojombo/grit.git
```

#### 添加远程仓库

`git remote add [shortname] [url]`

#### 从远程仓库抓取数据

```
$ git fetch [remote-name]
```

此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。

fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。

#### 推送数据到远程仓库

```
git push [remote-name] [branch-name]
```

只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。

#### 查看远程仓库信息

`git remote show [remote-name]`

#### 远程仓库的删除和重命名

```
$ git remote rename pb paul
```

```
$ git remote rm paul
```

### 打标签

Git 也可以对某一时间点上的版本打上标签。

#### 列显已有的标签

列出现有标签的命令非常简单，直接运行 `git tag` 即可：

```
$ git tag
    v0.1
    v1.3
```

用特定的搜索模式列出符合条件的标签。

```
$ git tag -l 'v1.4.2.*'
    v1.4.2.1
    v1.4.2.2
    v1.4.2.3
    v1.4.2.4
```

#### 新建标签

Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明

##### 含附注的标签

创建一个含附注类型的标签非常简单，用 `-a` 

```
$ git tag -a v1.4 -m 'my version 1.4'
    $ git tag
    v0.1
    v1.3
    v1.4
```

##### 轻量级标签

轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。

```
$ git tag v1.4-lw
    $ git tag
    v0.1
    v1.3
    v1.4
    v1.4-lw
    v1.5
```

#### 分享标签

默认情况下，`git push` 并不会把标签传送到远端服务器上，`git push origin [tagname]` 

如果要一次推送所有本地新增的标签上去，可以使用 `git push origin --tags` 

## git分支

使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。

Git 保存的不是文件差异或者变化量，而只是一系列文件快照。在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。

当使用 `git commit` 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。  

![img](https://gitee.com/progit/figures/18333fig0301-tn.png) 

作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针

![img](https://gitee.com/progit/figures/18333fig0302-tn.png) 

Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针，Git 会使用 master 作为分支的默认名字。它在每次提交的时候都会自动向前移动。

![img](https://gitee.com/progit/figures/18333fig0303-tn.png) 

创建一个新的分支指针。比如新建一个 testing 分支，可以使用 `git branch` 命令：

```
$ git branch testing
```

![img](https://gitee.com/progit/figures/18333fig0304-tn.png) 

Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。在 Git 中，它是一个指向你正在工作中的本地分支的指针

切换到其他分支，==本质就是将HEAD指针指向不同的分支==，可以执行 `git checkout` 命令

```
$ git checkout testing
```

![img](https://gitee.com/progit/figures/18333fig0306-tn.png) 

每次提交后 HEAD 随着分支一起向前移动

由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。

###  分支的新建与合并

#### 分支的新建与切换

![img](https://gitee.com/progit/figures/18333fig0310-tn.png) 

新建的分支取名为 iss53。要新建并切换到该分支，运行 `git checkout` 并加上 `-b` 参数：

```
$ git checkout -b iss53
```

相当于执行下面这两条命令：

```
$ git branch iss53
$ git checkout iss53
```

![img](https://gitee.com/progit/figures/18333fig0311-tn.png) 

在提交了若干次更新后，`iss53` 分支的指针也会随着向前推进

![img](https://gitee.com/progit/figures/18333fig0312-tn.png) 

再创建一个`hotfix` 分支展开工作，切换分支时，Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。

![img](https://gitee.com/progit/figures/18333fig0313-tn.png) 

合并master和hotfix

```
$ git checkout master
$ git merge hotfix
```

注意，合并时出现了==“Fast forward”==的提示。由于当前 `master` 分支所在的提交对象是要并入的 `hotfix` 分支的直接上游，Git 只需把 `master` 分支指针直接右移。

![img](https://gitee.com/progit/figures/18333fig0314-tn.png) 

`hotfix` 已经完成了历史使命，可以删掉了。使用 `git branch` 的 `-d` 选项执行删除操作：

```
$ git branch -d hotfix
```

#### 分支的合并

运行`git merge` 命令指定要合并进来的分支

```
git merge iss53
```

注意，这次合并操作的底层实现，并不同于之前 `hotfix` 的并入方式。Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。

![img](https://gitee.com/progit/figures/18333fig0316-tn.png) 

Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。

![img](https://gitee.com/progit/figures/18333fig0317-tn.png) 

#### 遇到冲突时的分支合并

如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）

任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。

```html
<<<<<<< HEAD:index.html
    <div id="footer">contact : email.support@github.com</div>
    =======
    <div id="footer">
    please contact us at support@github.com
    </div>
    >>>>>>> iss53:index.html
```

解决了所有文件里的所有冲突后，运行 `git add` 将把它们标记为已解决状态

### 分支的管理

`git branch` 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：

```bash
$ git branch
    iss53
    * master  ##  分支前的 * 字符：它表示当前所在的分支	
    testing
```

查看各个分支最后一个提交对象的信息，运行 `git branch -v`

筛选出你已经（或尚未）与当前分支合并的分支，可以用 `--merge` 和 `--no-merged` 选项比如用 `git branch --merge` 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：

```
$ git branch --merged
$ git branch --no-merged
```

列表中没有 `*` 的分支通常都可以用 `git branch -d` 来删掉。但分支中还包含着尚未合并进来的工作成果会提示错误，因为那样做会丢失数据：可以用大写的删除选项 `-D` 强制执行

#### 远程分支

远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。

 `(远程仓库名)/(分支名)` 这样的形式表示远程分支。比如我们想看看上次同 `origin` 仓库通讯时 `master` 分支的样子，就应该查看`origin/master` 分支。

##### 克隆

Git 会自动为你将此远程仓库命名为 `origin`，并下载其中所有的数据，建立一个指向它的 `master` 分支的指针，在本地命名为 `origin/master`，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 `master` 分支，始于 `origin` 上 `master` 分支相同的位置，你可以就此开始工作：

![img](https://gitee.com/progit/figures/18333fig0322-tn.png) 

一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 `origin` 上的 `master` 分支（==注意：git的分布式特性，虽然实际上都指向本地克隆后的分支，但本地克隆和远端分支是一模一样的，所以即也等效于指向了远程分支 origin/master，但注意此时有两个分支指针，local和remote==）。

如果你在本地 `master` 分支做了些改动，与此同时，其他人向 `git.ourcompany.com` 推送了他们的更新，那么服务器上的 `master` 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 `origin/master` 指针仍然保持原位不会移动。

![img](https://gitee.com/progit/figures/18333fig0323-tn.png) 

在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。

可以运行 `git fetch origin` 来同步远程服务器上的数据到本地。该命令首先找到 `origin` 是哪个服务器（本例为 `git.ourcompany.com`），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 `origin/master` 的指针移到它最新的位置上

![img](https://gitee.com/progit/figures/18333fig0324-tn.png) 

#### 推送本地分支

`git push (远程仓库名) (分支名)`

若想把远程分支叫作 `awesomebranch`，可以用 `git push origin serverfix:awesomebranch`

#### 跟踪远程分支

从远程分支 `checkout` 出来的本地分支，称为 *跟踪分支* (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 `git push`，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 `git pull` 会获取所有远程索引，并把它们的数据都合并到本地分支中来。

`git checkout -b [分支名][远程名]/[分支名]`

#### 删除远程分支

`git push [远程名] :[分支名]`

> `git push [远程名] [本地分支]:[远程分支]` 语法，如果省略 `[本地分支]`，那就等于是在说“在这里提取空白然后把它变成`[远程分支]`”

### 分支的衍合

把一个分支中的修改整合到另一个分支的办法有两种：`merge` 和 `rebase`

#### merge

它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）

![img](https://gitee.com/progit/figures/18333fig0328-tn.png) 

#### 衍合（rebase）

把在一个分支里提交的改变移到另一个分支里重放一遍。

```
$ git checkout experiment
$ git rebase master
```

它的原理是回到两个分支最近的共同祖先，根据当前分支（`experiment`）后续的历次提交对象（C3），生成一系列文件补丁，然后以基底分支（ `master`）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3'），从而改写 `experiment` 的提交历史，使它成为 `master` 分支的直接下游

![img](https://gitee.com/progit/figures/18333fig0329-tn.png) 

回到 `master` 分支，进行一次快进合并,==注意这里的master没有指向C3‘==

![img](https://gitee.com/progit/figures/18333fig0330-tn.png) 

注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。

一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 ,衍合能产生一个更为整洁的提交历史。

##### 衍合的风险

**一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。**

在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 `git rebase` 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。

![img](https://gitee.com/progit/figures/18333fig0339-tn.png) 

如图，C7先merge了C3和C6，后另一个人将C4按基C5 rebase，合并后master上指向C4’，然后下面的人需要mergeC4' 和C7，此时C7已包含C4，C4‘内容包含了C4的改动，但此时衍合产生的提交对象 C4' 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，把相同的内容又合并了一遍

## 服务器上的 Git

远程仓库通常只是一个*裸仓库（bare repository）* — 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中 `.git` 子目录内的内容。

### 协议

Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议

## 分布式 Git

### 集中式工作流

一个存放代码仓库的中心服务器，可以接受所有开发者提交的代码。

![img](https://gitee.com/progit/figures/18333fig0501-tn.png) 

如果两个开发者从中心仓库克隆代码下来，同时作了一些修订，那么只有第一个开发者可以顺利地把数据推送到共享服务器。第二个开发者在提交他的修订之前，必须先下载合并服务器上的数据，解决冲突之后才能推送数据到共享服务器上。

### 集成管理员工作流

由于 Git 允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以从别人的仓库中提取他们的更新过来。这种情形通常都会有个代表着官方发布的项目仓库（blessed repository），开发者们由此仓库克隆出一个自己的公共仓库（developer public），然后将自己的提交推送上去，请求官方仓库的维护者拉取更新合并到主项目。维护者在自己的本地也有个克隆仓库（integration manager），他可以将你的公共仓库作为远程仓库添加进来，经过测试无误后合并到主干分支，然后再推送到官方仓库。

1. 项目维护者可以推送数据到公共仓库 blessed repository。
2. 贡献者克隆此仓库，修订或编写新代码。
3. 贡献者推送数据到自己的公共仓库 developer public。
4. 贡献者给维护者发送邮件，请求拉取自己的最新修订。
5. 维护者在自己本地的 integration manger 仓库中，将贡献者的仓库加为远程仓库，合并更新并做测试。
6. 维护者将合并后的更新推送到主仓库 blessed repository。

![img](https://gitee.com/progit/figures/18333fig0502-tn.png) 

### 司令官与副官工作流

负责集成项目中的特定部分，所以称为副官（lieutenant）。而所有这些集成管理员头上还有一位负责统筹的总集成管理员，称为司令官（dictator）。司令官维护的仓库用于提供所有协作者拉取最新集成的项目代码。

1. 一般的开发者在自己的特性分支上工作，并不定期地根据主干分支（dictator 上的 master）衍合。
2. 副官（lieutenant）将普通开发者的特性分支合并到自己的 master 分支中。
3. 司令官（dictator）将所有副官的 master 分支并入自己的 master 分支。
4. 司令官（dictator）将集成后的 master 分支推送到共享仓库 blessed repository 中，以便所有其他开发者以此为基础进行衍合。

![img](https://gitee.com/progit/figures/18333fig0503-tn.png) 

这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。（分而治之）

## git 工具

### 储藏（Stashing）

当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是`git stash`命令。

“‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。

#### 储藏你的工作

为了往堆栈推送一个新的储藏，只要运行 `git stash`：

这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 `git stash list`

### 重写历史

### 改变最近一次提交

两件基本事情：改变提交说明，或者改变你刚刚通过增加，改变，删除而记录的快照。

```
$ git commit --amend
```

**`git commit --amend`会获取你当前的暂存区并将它作为新提交对应的快照。**

修正会改变提交的SHA-1值。这个很像是一次非常小的rebase——不要在你最近一次提交被推送后还去修正它。

### Git挂钩

当某些重要事件发生时，Git 以调用自定义脚本。有两组挂钩：客户端和服务器端。客户端挂钩用于客户端的操作，如提交和合并。服务器端挂钩用于 Git 服务器端的操作，如接收被推送的提交。

#### 安装一个挂钩

挂钩都被存储在 Git 目录下的`hooks`子目录中，即大部分项目中的`.git/hooks`。 





